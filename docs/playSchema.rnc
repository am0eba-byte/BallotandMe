start = root

root = element root {head, body}

head = element head {title, editor*}

    title = element title {text}
        
    editor = element editor {text}
        
        
body = element body {(titlePage)?, (pgbr)?, (castList)?, (pgbr)?, (set)?, (playstrt)?, (div1 | pg)*}

pg = element pg {n, empty}

pgbr = element pgbr {empty}

playstrt = element playstrt {empty}

# mia: I put question mark repetition indicators on everything except div1 so that when Mckenna and Brett do their portions,
# the schema won't yell at them to put in the title page, cast list and set pages!



# ebb: I notice you removed this element from the rule for body for now...that's okay, but right now there's no place for <pg> to go yet.
# My suggestion is maybe get a complete encoding of the play, and mark the page breaks in with XML comments. Then turn them into <pg/> elements and just notice from the angry schema errors which elements are containing them.
# Then we can go back and work out which elements need to hold <pg> here. 


    n = attribute n {xsd:integer}


titlePage = element titlePage {copy, playtitle, titledesc, author, published, marginalia}

    copy = element copy {underline}
    
    playtitle = element playtitle {underline}

    titledesc = element titledesc {mixed{lb+}}

author = element author {mixed{lb*}}

published = element published {(pubPlace | date | lb)*}

    pubPlace = element pubPlace {text}

    date = element date {when, text}

        when = attribute when {xsd:gYear}

marginalia = element marginalia {hand, mixed{lb*}}

    hand = attribute hand {"LH"}


castList = element castList {header, (castgroup | castItem)*, note}

    header = element header {mixed{ (underline | lb)*}}

    castItem = element castItem {mixed{ (unclear | role | margin | lb | person)* } }
    
        unclear = element unclear {text}
    
        role = element role {text}

        margin = element margin {(castGroupRole | position)*, mixed{(lb | period | date)*}}
        
        lb = element lb {empty}
        
        # mia: add lb element to cast items to indicate line breaks
        
            castGroupRole = attribute castGroupRole {xsd:integer}
        
            position = attribute position {"right"}

            period = element period {begin, end, text}
            
                begin = attribute begin {xsd:gYear}
                
                end = attribute end {xsd:gYear}

    castgroup = element castgroup {n, castItem*, margin*}
    
    
    note = element note {hand?, p}


set = element set {header, setting, setTime, action}

    setting = element setting {ab, setDesc}
    
        ab = element ab {text}
        
        setDesc= element setDesc {text}
        
    setTime = element setTime {ab, timedesc}
    
        timedesc = element timedesc {text}
    
    action = element action {ab, actiondesc}
    
        actiondesc = element actiondesc {mixed{lb*}}
    

    div1 = element div1 {(sp | stage)*}

    sp = element sp {(speaker | dialogue | metamark)*}
    
        speaker = element speaker {idref?, mixed{lb*}}
            
         dialogue = element dialogue {(p | stage)*}
         
         # mia: fix dialogue element rule to fit Dr B's suggestion
         
         # ebb: Hmmm. Are you SURE you want your <dialogue> element to contain mixed content? That would mean that text is flowing around the outside of the <p> and <q> elements...
         # Think about the relationship of these elements in your code. From what I can see in the sample code so far, it looks like <dialogue> just contains <p> elements?  I think I'd just change this to:
         # dialogue = element dialogue {p+}  
         # Does that work?
         
         p = element p {class?, mixed{ (note | metamark | insert | underline | Xout | q | lb | stage | date | location | person)* } }
         
         # mia: fixed element p rule to match Dr. B's suggestion
         
         # ebb: Do you want your mixed content elements to appear in ANY order here? If so, you want to rephrase your mixed{} a little. The parentheses are for grouping sets of elements together:
         # Try this: p = element p {class?, mixed{ (note | metamark | underline | Xout | q)* }
         # That syntax basically says, you're allowed an option of ANY of those elements, zero or more times! (And that means they can appear in any order, too. 
         # Looking at your play script, I think you're considering catching the line-beginnings--right now you're using pseudomarkup for that with the // characters. 
         # You could try a self-closing <lb/> element for those: would you always want those to go inside <p> elements? That way you could calculate numbered lines for each character's speech! 
        
            location = element location {mixed{lb*}}
            
            person = element person {(id | idref)*, mixed{lb*}}
            
            id = attribute xml:id {xsd:ID}
            
            idref = attribute idref {xsd:IDREF}
            
            class = attribute class {"navbar"}
            
            metamark = element metamark {hand, text}
            
            insert = element insert {hand, text}
            
            underline = element underline {color?, mixed{lb*}}
                
                color = attribute color {"red"}
            
            Xout = element Xout {text}
            
            q = element q {mixed{(lb | underline)*}}
            
     stage = element stage {(type | idref)*, mixed{(lb | person)*}}
    
        type = attribute type {"enter" | "action" }
        
